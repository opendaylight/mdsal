@*
 * Copyright (c) 2016 Cisco Systems, Inc. and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 *@

@**********************************************************
* Twirl unionTemplate for generating Java interface       *
* source code. Twirl is transformed to Scala and compiled.*
* Then, it can be called from Java with particular input  *
* parameters to render desired output code.               *
*                                                         *
* Note: we should introduce our own format instead of txt *
***********************************************************@

@import java.util.List
@import org.opendaylight.mdsal.binding2.model.api.GeneratedType
@import org.opendaylight.mdsal.binding2.model.api.GeneratedProperty
@import org.opendaylight.mdsal.binding2.model.api.GeneratedTransferObject
@import org.opendaylight.mdsal.binding2.java.api.generator.util.TextTemplateUtil.fieldName
@import org.opendaylight.mdsal.binding2.java.api.generator.util.TextTemplateUtil.asArguments

@(baseType: GeneratedType, importedNames: Map[String, String], finalProperties: List[GeneratedProperty],
parentProperties: List[GeneratedProperty], properties: List[GeneratedProperty], propertyList: String)
@if(baseType != null) {
    uniontempalte
}

@unionConstructors() = {
@for(property <- finalProperties) {
    @if("char[]".equals(property.getReturnType().getName())) {
    /**
     * Constructor provided only for using in JMX. Don't use it for
     * construction new object of this union type.
     */
    @@@{importedNames.get("constructorProperties")}("@{property.getName()}")
    public @{baseType.getName()}({importedNames.get(property.getName())} @{fieldName(property)}) {
        @{importedNames.get("string")} defVal = new @{importedNames.get("string")}(@{fieldName(property)});
        @{baseType.getName()} defInst = @{typeBuilder()}.getDefaultInstance(defVal);
        @for(otherProperty <- finalProperties) {
            this.@{fieldName(otherProperty)} =
            @if("value".equals(otherProperty.getName())) {
                @if(importedNames.get(otherProperty.getName()).contains("[]")) {
                    @{fieldName(otherProperty)} == null ? null : @{fieldName(otherProperty)}.clone();
                } else {
                    @{fieldName(otherProperty)};
                }
            } else {
                defInst.@{fieldName(otherProperty)};
            }
        }
    }
    } else {
        @*FIX ME parentProperties + #[property] as argument to method below see  unionTemplate 84 *@
        public @{baseType.getName()}() {
            super(@{asArguments(parentProperties)});
            this.@{fieldName(property)} = @{fieldName(property)};
            @for(otherProperty <- finalProperties) {
                @if(property != otherProperty && !"value".equals(otherProperty.getName())) {
                    this.@{fieldName(otherProperty)} = null;
                }
            }
        }
    }
}
}

@copyConstructor() = {
    /**
     * Creates a copy from Source Object.
     *
     * @@param source Source object
     */
    public @{baseType.getName()}
    (@{baseType.getName()}
     source) {
    @if(!parentProperties.isEmpty()) {super(source);}
    @{propertyList}
    }
}

@typeBuilder() = {
    @*FIX ME this can be omited because we dont have inner classes ?*@
    @{baseType.getName}Builder
}