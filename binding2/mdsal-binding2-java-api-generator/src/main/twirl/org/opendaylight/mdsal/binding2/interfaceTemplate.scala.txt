@**********************************************************
* Twirl InterfaceTemplate for generating Java interface   *
* source code. Twirl is transformed to Scala and compiled.*
* Then, it can be called from Java with particular input  *
* parameters to render desired output code.               *
*                                                         *
* Note: we should introduce our own format instead of txt *
***********************************************************@

@import java.util.List
@import org.opendaylight.mdsal.binding2.model.api.AnnotationType
@import org.opendaylight.mdsal.binding2.model.api.Constant
@import org.opendaylight.mdsal.binding2.model.api.Enumeration
@import org.opendaylight.mdsal.binding2.model.api.GeneratedTransferObject
@import org.opendaylight.mdsal.binding2.model.api.GeneratedType
@import org.opendaylight.mdsal.binding2.model.api.MethodSignature
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.asJavadoc
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.emitConstant
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.formatDataForJavaDoc
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.generateImports
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.generateParameters
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.generateParametersForAnnotation
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getJavaDocForInterface
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.importedName
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.isAccessor
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.PATTERN_CONSTANT_NAME
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.wrapToDocumentation

@(genType: GeneratedType)
@*
 * Template method which generate the whole body of the interface.
 *
 * @return string with code for interface body in JAVA format
 *@
@if(genType != null) {
@{wrapToDocumentation(formatDataForJavaDoc(genType))}
@generateAnnotations(genType.getAnnotations())
public interface @{genType.getName()}
    @superInterfaces(genType)
{
    @generateInnerClasses(genType)
    @generateEnums(genType.getEnumerations())
    @generateConstants(genType.getConstantDefinitions())
    @generateMethods(genType.getMethodDefinitions())
}
}

@generateAnnotations(annotations: List[AnnotationType]) = {
    @if(annotations != null && !annotations.isEmpty()) {
        @for(annotation <- annotations) {
            @@@{importedName(annotation)}
            @if(annotation.getParameters() != null && !annotation.getParameters().isEmpty()) {
                (
                @{generateParametersForAnnotation(annotation.getParameters())}
                )
            }
        }
    }
}

@*
 * Template method which generates the interface name declaration.
 *
 * @return string with the code for the interface declaration in JAVA format
 *@
@superInterfaces(genType: GeneratedType) = {
    @if(!genType.getImplements().isEmpty()) {
        extends @{generateImports(genType.getImplements())}
    }
}

@*
 * Template method which generates inner classes inside this interface.
 *
 * @return string with the source code for inner classes in JAVA format
 *@
@generateInnerClasses(genType: GeneratedType) = {
    @if(!genType.getEnclosedTypes().isEmpty()) {
        @for(innerClass <- genType.getEnclosedTypes()) {
            @if(innerClass.isInstanceOf[GeneratedTransferObject]) {
                @if(innerClass.asInstanceOf[GeneratedTransferObject].isUnionType()) {
                    @* generate union template add to import map *@
                } else {
                    @* generate class template add to import map *@
                }
            }
        }
    }
}

@*
 * Template method which generates JAVA enum type.
 *
 * @return string with inner enum source code in JAVA format
 *@
@generateEnums(enumerations: List[Enumeration]) = {
    @if(!enumerations.isEmpty()) {
        @for(enumeration <- enumerations) {
            @* generate enum template as inner class*@
        }
    }
}

@*
 * Template method wich generates JAVA constants.
 *
 * @return string with constants in JAVA format
 *@
@generateConstants(constants: List[Constant]) = {
    @if(!constants.isEmpty()) {
        @for(constant <- constants) {
            @if(constant.getName() != PATTERN_CONSTANT_NAME) {
                @{emitConstant(constant)}
            }
        }
    }
}

@*
 * Template method which generates the declaration of the methods.
 *
 * @return string with the declaration of methods source code in JAVA format
 *@
@generateMethods(methodSignatures: List[MethodSignature]) = {
    @if(!methodSignatures.isEmpty()) {
        @for(methodSignature <- methodSignatures) {
            @if(!isAccessor(methodSignature)) {
                @{asJavadoc(methodSignature.getComment())}
            }else{
            @{getJavaDocForInterface(methodSignature)}
            }
            @generateAnnotations(methodSignature.getAnnotations())
            @{importedName(methodSignature.getReturnType())} @{methodSignature.getName()}
            (@{generateParameters(methodSignature.getParameters())});
        }
    }
}