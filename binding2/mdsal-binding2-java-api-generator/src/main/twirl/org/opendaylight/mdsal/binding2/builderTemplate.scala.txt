@**********************************************************
* Twirl InterfaceTemplate for generating Java interface   *
* source code. Twirl is transformed to Scala and compiled.*
* Then, it can be called from Java with particular input  *
* parameters to render desired output code.               *
*                                                         *
* Note: we should introduce our own format instead of txt *
***********************************************************@

@import java.util.List
@import org.opendaylight.mdsal.binding2.model.api.Enumeration
@import org.opendaylight.mdsal.binding2.model.api.GeneratedType
@import org.opendaylight.mdsal.binding2.model.api.GeneratedTransferObject
@import org.opendaylight.mdsal.binding2.model.api.GeneratedProperty
@import org.opendaylight.mdsal.binding2.model.api.Type
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.fieldName
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.formatDataForJavaDoc
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.importedName
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.wrapToDocumentation
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getSimpleNameForBuilder
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.propertyNameFromGetter
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getImportedNameArrays
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getImportedNameObject
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getImportedNameObjects
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getImportedNameString
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getImportedNameStringBuilder
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getImportedNameForMap
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getImportedNameForClass
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getImportedNameForCollections
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getImportedNameHashMap
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getterMethod
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.getterMethodName
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BaseTemplateUtil.toFirstUpper
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BuilderTemplateUtil.generateProperties
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BuilderTemplateUtil.getAllIfcs
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BuilderTemplateUtil.getAugmentField
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BuilderTemplateUtil.hasImplementsFromUses
@import org.opendaylight.mdsal.binding2.java.api.generator.util.BuilderTemplateUtil.toListOfNames
@import org.opendaylight.yangtools.concepts.Builder

@(genType: GeneratedType)
@if(genType != null) {
    @{wrapToDocumentation(formatDataForJavaDoc(genType))}
    @* this formatDataForJavaDoc is not the older one need another implementation *@
    public class @{genType.getName()}Builder implements @{getSimpleNameForBuilder()} <@{importedName(genType)}> {

        @generateFields(false, genType)

        @generateAugmentField(false, genType)

        @generateConstructorsFromIfcs(genType)

        @generateCopyConstructor(false, genType)

        @generateMethodFieldsFrom(genType)

        @generateGetters(false, genType, generateProperties(genType))

        @generateSetters(false, genType, generateProperties(genType))

        public @{genType.getName()} build() {
            return new @{genType.getName()}Impl(this);
        }

        private static final class @{genType.getName()}Impl implements @{genType.getName()} {

            @implementedInterfaceGetter(genType)

            @generateFields(true, genType)

            @generateAugmentField(true, genType)

            @generateCopyConstructor(true, genType)

            @generateGetters(true, genType, generateProperties(genType))

            @generateHashCode(generateProperties(genType))

            @generateEquals(generateProperties(genType), genType)

            @generateToString(generateProperties(genType), genType)
        }
    }
}

@**
 * Template method which generates class attributes.
 *
 * @param isFinal value which specify whether field is|isn't final
 * @param genType is genType
 * @return string with class attributes and their types
 *@
@generateFields(isFinal: Boolean, genType: GeneratedType) = {
    @if(generateProperties(genType) != null) {
        @for(property <- generateProperties(genType)) {
            private @if(isFinal) { final}
            @{importedName(property.getReturnType())} @{fieldName(property)};
        }
    }
}

@**
 * Template method which generates class attributes.
 *
 * @param boolean value which specify whether field is|isn't final
 * @return string with class attributes and their types
 *@
@generateAugmentField(isPrivate: Boolean, genType: GeneratedType) = {
    @if(getAugmentField() != null) {
        @if(isPrivate) {private }
        @{getImportedNameForMap()}<@{getImportedNameForClass()}<? extends@{importedName(getAugmentField().getReturnType())}>,
        @{importedName(getAugmentField().getReturnType())}>@{getAugmentField().getName()} = @{getImportedNameForCollections()}.emptyMap();
    }
}

@implementedInterfaceGetter(genType: GeneratedType) = {
    public @{getImportedNameForClass()}<@{importedName(genType)}> getImplementedInterface() {
    return @{importedName(genType)}.class;
    }
}

@**
 * Generate default constructor and constructor for every implemented interface from uses statements.
 *@
@generateConstructorsFromIfcs(genType: GeneratedType) = {
    public @{genType.getName()}Builder() {
    }
    @if(genType.isInstanceOf[GeneratedType] && !genType.isInstanceOf[GeneratedTransferObject]) {
        @for(impl <- genType.asInstanceOf[GeneratedType].getImplements()) {
            @generateConstructorFromIfc(impl)
        }
    }
}

@generateMethodFieldsFrom(genType: GeneratedType) = {
    @if(genType.isInstanceOf[GeneratedType] && !genType.isInstanceOf[GeneratedTransferObject]) {
        @if(hasImplementsFromUses(genType.asInstanceOf[GeneratedType])) {
            /**
             *Set fields from given grouping argument. Valid argument is instance of one of following types:
             * <ul>
             @for(impl <- getAllIfcs(genType.asInstanceOf[GeneratedType])) {
             * <li>@{impl.getFullyQualifiedName()}</li>
             }
             * </ul>
             *
             * @@param arg grouping object
             * @@throws IllegalArgumentException if given argument is none of valid types
            */

            @*FIX ME DataObejct imported name*@
            public void fieldsFrom(«DataObject.importedName» arg) {
                boolean isValidArg = false;
                @for(impl <- getAllIfcs(genType.asInstanceOf[GeneratedType])) {
                    @if(impl.isInstanceOf[GeneratedType] && !impl.asInstanceOf[GeneratedType].getMethodDefinitions().isEmpty()) {
                        if (arg instanceof @{impl.asInstanceOf[GeneratedType].getFullyQualifiedName()}) {
                            @if(!impl.isInstanceOf[GeneratedTransferObject]) {
                                @for(getter <- genType.asInstanceOf[GeneratedType].getMethodDefinitions()) {
                                    this._@{propertyNameFromGetter(getter)} = ((@{impl.asInstanceOf[GeneratedType].getFullyQualifiedName()})arg).@{getter.getName()}();
                                }
                            }
                            isValidArg = true;
                        }
                    }
                }
                if (!isValidArg) {
                    throw new IllegalArgumentException(
                      "expected one of: @{toListOfNames(getAllIfcs(genType.asInstanceOf[GeneratedType]))} \n" +
                      "but was: " + arg
                    );
                }
            }
        }
    }
}

@**
 * Generate constructor with argument of given type.
 *@
@generateConstructorFromIfc(impl: Type) = {
    @if(impl.isInstanceOf[GeneratedType]) {
        @if(!impl.asInstanceOf[GeneratedType].getMethodDefinitions().isEmpty()) {
            public
            @*This type should be set on util CARE ! to do fix me*@
            @*@{type.getName()}Builder*@
            (
            @{impl.getFullyQualifiedName()} arg) {
            @{printConstructorPropertySetter(impl)}
            }
        }
        @for(implTypeImplement <- impl.asInstanceOf[GeneratedType].getImplements()) {
            @generateConstructorFromIfc(implTypeImplement)
        }
    }
}

@printConstructorPropertySetter(implementedIfc: Type) = {
    @if(implementedIfc.isInstanceOf[GeneratedType] && !implementedIfc.isInstanceOf[GeneratedTransferObject]) {
        @for(getter <- implementedIfc.asInstanceOf[GeneratedType].getMethodDefinitions()) {
            this._@{propertyNameFromGetter(getter)} = arg.@{getter.getName()}();
        }
        @for(impl <- implementedIfc.asInstanceOf[GeneratedType].getImplements()) {
            @{printConstructorPropertySetter(impl)}
        }
    }
}

@generateCopyConstructor(impl: Boolean, genType: GeneratedType) = {
    @if(impl) {private} else {public}
    @{genType.getName()}
    @if(impl) {Impl} else {Builder}
    (@{genType.getName()}@if(impl) {Builder} base) {
    @*FINISH below AugmentationHolder
    @for(field <- allProps) {
        this.@{fieldName(field)} = base.@{getterMethodName(field)}();
    }*@
    @if(getAugmentField() != null) {
        @if(impl) {
            switch (base.@{getAugmentField().getName()}.size()) {
            case 0:
                this.@{getAugmentField().getName()} = @{getImportedNameForCollections()}.emptyMap();
                break;
            case 1:
                final @{getImportedNameForMap()}.Entry<@{getImportedNameForClass}<? extends @{importedName(getAugmentField().getReturnType())}>, @{importedName(getAugmentField().getReturnType())}> e = base.@{getAugmentField().getName()}.entrySet().iterator().next();
                this.@{getAugmentField().getName()} = @{getImportedNameForCollections()}.<@{getImportedNameForClass}<? extends @{importedName(getAugmentField().getReturnType())}>, @{importedName(getAugmentField().getReturnType())}>singletonMap(e.getKey(), e.getValue());
                break;
            default :
                this.@{getAugmentField().getName()} = new @{getImportedNameHashMap()}<>(base.@{getAugmentField().getName()});
            }
        } else {
            if (base instanceof @{genType.getName()}Impl) {
                @{genType.getName()}Impl impl = (@{genType.getName()}Impl) base;
                if (!impl.@{getAugmentField().getName()}.isEmpty()) {
                    this.@{getAugmentField().getName()} = new @{getImportedNameHashMap()}<>(impl.@{getAugmentField().getName()});
                }
            } @{"else"} if (base instanceof «AugmentationHolder.importedName») {
                @@SuppressWarnings("unchecked")
                «AugmentationHolder.importedName»<@{importedName(genType)}> casted =(«AugmentationHolder.importedName»<@{importedName(genType)}>) base;
                if (!casted.augmentations().isEmpty()) {
                    this.@{getAugmentField().getName()} = new @{getImportedNameHashMap()}<>(casted.augmentations());
                }
            }
        }
    }
    }
}


@generateSetters(addOverride: Boolean, genType: GeneratedType, properties: Collection[GeneratedProperty]) = {
    @for(field <- properties) {
        @if(true) {
            FINISH
        }
        public @{genType.getName()}Builder set@{toFirstUpper(field.getName())}(final @{importedName(field.getReturnType())} value) {
        @if(true) {
            FINISH
        }
            this.@{fieldName(field)} = value;
            return this;
        }
    }
    @if(getAugmentField() != null) {
        public @{genType.getName()}Builder add@{toFirstUpper(getAugmentField().getName())}(@{getImportedNameForClass()}<?
        extends @{importedName(getAugmentField().getReturnType())}> augmentationType, @{importedName(getAugmentField().getReturnType())} augmentation) {
            if (augmentation == null) {
                return remove@{toFirstUpper(getAugmentField().getName())}(augmentationType);
            }

            if (!(this.@{getAugmentField().getName()} instanceof @{getImportedNameHashMap()})) {
                this.@{getAugmentField().getName()} = new @{getImportedNameHashMap()}<>();
            }

            this.@{getAugmentField().getName()}.put(augmentationType, augmentation);
            return this;
        }

        public @{genType.getName()}Builder remove@{toFirstUpper(getAugmentField().getName())}
        (@{getImportedNameForClass()}<? extends @{importedName(getAugmentField().getReturnType())}> augmentationType) {
            if (this.@{getAugmentField().getName()} instanceof @{getImportedNameHashMap()}) {
                this.@{getAugmentField().getName()}.remove(augmentationType);
            }
            return this;
        }
    }
}

@generateGetters(addOverride: Boolean, genType: GeneratedType, properties: Collection[GeneratedProperty]) = {
    @if(!properties.isEmpty()) {
        @for(property <- properties) {
            @if(addOverride) {@@Override}
            @{getterMethod(property)}
        }
    }
    @if(getAugmentField() != null) {
        @@SuppressWarnings("unchecked")
        @if(addOverride) {@@Override}
        public <E extends @{importedName(getAugmentField().getReturnType())}> E get@{toFirstUpper(getAugmentField().getName())}(@{getImportedNameForClass()}<E> augmentationType) {
            if (augmentationType == null) {
                throw new IllegalArgumentException("Augmentation Type reference cannot be NULL!");
            }
            return (E) @{getAugmentField().getName()}.get(augmentationType);
        }
    }
}

@generateHashCode(properties: Collection[GeneratedProperty]) = {
    @if(!properties.isEmpty() || getAugmentField() != null) {
        private int hash = 0;
        private volatile boolean hashValid = false;

        @@Override
        public int hashCode() {
            if (hashValid) {
                return hash;
            }

            final int prime = 31;
            int result = 1;

            @for(property <- properties) {
                @if(property.getReturnType().getName().contains("[")) {
                    result = prime * result + @{getImportedNameArrays}.hashCode(@{fieldName(property)});
                } else {
                    result = prime * result + @{getImportedNameObjects}.hashCode(@{fieldName(property)});
                }
            }
            @if(getAugmentField() != null) {
                result = prime * result + @{getImportedNameObjects()}.hashCode(@{getAugmentField.getName()});
            }

            hash = result;
            hashValid = true;
            return result;
        }
    }
}

@generateToString(properties: Collection[GeneratedProperty], genType: GeneratedType) = {
    @if(properties == null) {
        @@Override
        public @{getImportedNameString} toString() {
            @{getImportedNameStringBuilder()} builder = new @{getImportedNameStringBuilder()}("@{genType.getName()} [");
            boolean first = true;
            @for(property <- properties) {
                if (@{fieldName(property)} != null) {
                    if (first) {
                        first = false;
                    } else {
                        builder.append(", ");
                    }
                    builder.append("@{fieldName(property)}=");
                    @if(property.getReturnType().getName().contains("[")) {
                        builder.append(@{getImportedNameArrays()}.toString(@{fieldName(property)}));
                    } else {
                        builder.append(@{fieldName(property)});
                    }
                }
            }
            @if(getAugmentField() != null) {
                if (first) {
                    first = false;
                } @{"else"} {
                    builder.append(", ");
                }
                builder.append("@{getAugmentField().getName()}=");
                builder.append(@{getAugmentField().getName()}.values());
            }
            return builder.append(']').toString();
        }
    }
}

@generateEquals(properties: Collection[GeneratedProperty], genType: GeneratedType) = {
    @*FIX ME DataObejct imported name*@
    @if(!properties.isEmpty() || getAugmentField() != null) {
        @@Override
        public boolean equals(@{getImportedNameObject()} obj) {
            if (this == obj) {
                return true;
            }
            if (!(obj instanceof «DataObject.importedName»)) {
                return false;
            }
            if (!@{importedName(genType)}.class.equals(((«DataObject.importedName»)obj).getImplementedInterface())) {
                return false;
            }
            @{importedName(genType)} other = (@{importedName(genType)})obj;
            @for(property <- properties) {
                @if(property.getReturnType().getName().contains("[")) {
                    if (!@{getImportedNameArrays()}.equals(@{fieldName(property)}, other.@{getterMethodName(property)}()))
                } else {
                    if (!@{getImportedNameObjects()}.equals(@{fieldName(property)}, other.@{getterMethodName(property)}()))
                }
                {
                    return false;
                }
            }
            @if(getAugmentField() != null) {
                if (getClass() == obj.getClass()) {
                    // Simple case: we are comparing against self
                    @{genType.getName()}Impl otherImpl = (@{genType.getName()}Impl) obj;
                    if (!@{getImportedNameObjects()}.equals(@{getAugmentField().getName()}, otherImpl.@{getAugmentField().getName()})) {
                        return false;
                    }
                } @{"else"} {
                    // Hard case: compare our augments with presence there...
                    for (@{getImportedNameForMap()}.Entry<@{getImportedNameForClass()}<? extends @{importedName(getAugmentField().getReturnType())}>,
                    @{importedName(getAugmentField().getReturnType())}> e : @{getAugmentField().getName()}.entrySet()) {
                        if (!e.getValue().equals(other.getAugmentation(e.getKey()))) {
                            return false;
                        }
                    }
                    // .. and give the other one the chance to do the same
                    if (!obj.equals(this)) {
                        return false;
                    }
                }
            }
            return true;
        }
    }
}