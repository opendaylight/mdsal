module yang-ext {
    yang-version 1;
    namespace "urn:opendaylight:yang:extension:yang-ext";
    prefix "ext";

    contact "Anton Tkacik <ttkacik@cisco.com>";

    description
            "Copyright (c) 2013 Cisco Systems, Inc. and others.  All rights reserved.

            This program and the accompanying materials are made available under the
            terms of the Eclipse Public License v1.0 which accompanies this distribution,
            and is available at http://www.eclipse.org/legal/epl-v10.html";

    revision "2013-07-09" {
        description "Initial revision.";
    }

    // Augmentation name

    extension "augment-identifier" {
        description
           "YANG language extension which assigns an identifier to
            augmentation. Augment identifier is used to identify
            specific augment statement by name.

            The identifier syntax is formally defined by the 'identifier' rule
            in Section 12 of RFC 6020.

            All augment identifiers defined in a namespace MUST be unique.
            The namespace of augment identifiers is shared by module and
            its submodules. It is recommended that this namespace does not
            collide with schema node identifier namespace.";

        reference
            "Discussion:
                This extension allows for ease of development and debugging
                of YANG modules.

                The primary benefit is acts as a namespace anchor for namespace
                relocation -- for example when we want to share a number of YANG
                identifier namespaces inside a single Java identifier namespace --
                as it establishes identifier mapping rules in face of potential
                ambiguity.

                For example, imagine following (artificial) YANG fragment:

                  module foo {
                    namespace foo;
                    prefix foo;

                    import yang-ext { prefix ext; }

                    grouping foo {
                      leaf foo { type string; }
                    }

                    container foo {
                      uses foo;
                    }

                    augment /foo {
                      ext:augment-identifier foo-bar;
                      leaf bar { type uint8; }
                    }

                    augment /foo {
                      ext:augment-identifier foo-xyzzy
                      leaf xyxxy { type string; }
                    }
                  }

                treating each of grouping/container/augment as competing for Foo.class.

                A reasonable Java transpiler understanding this extension will treat
                the two augment statemtents as laying claim to FooBar.class and FooXyzzy.class,
                resulting in only grouping and container in contention";

        argument "identifier";
    }

    extension augment-equivalent {
        description
           "YANG language extension which instructs the code generator to treat
            this augmentation as equivalent of the specified augmentation.

            The argument identifies a sibling or top-level augmentation tagged with
            the augment-identifier extension. The argument syntax is formally
            defined by the 'node-identifier' rule in Section 12 or RFC 6020.";

        reference
            "Discussion:
                There are a number of cases where use of a particular grouping is
                being augmented with additional information -- for example adding
                use of another grouping.

                Each such augment results in a separate class being generated, which
                serves to confuse as usually these differ only in name. This extension
                allows manual suppression of such duplicates, improving ergonomics.";

        argument node-identifier;
    }

    // Mount point marker

    extension mount {
        description
           "YANG language extension which marks a place where a semantic mount
            point can be present. This extension can only be used in a container or
            a list statement, for example:

              module foo {
                container foo {
                  leaf bar {
                    type string;
                  }

                  ext:mount;
                }
              }

            In this example, container foo can contain a local leaf bar and some
            mounted data. From addressing perspective, the extension use acts as
            a container with yang-ext's namespace, i.e. it looks as though as this
            (yang-ext) module contained the following construct:

              import foo { prefix foo; }

              augment /foo:foo {
                container mount;
              }

            From data lifecycle perspective, this container should never be
            automatically included in the datastore content for 'container foo', unless
            specifically explicitly requested.";
    }

    // Context-aware RPCs

    grouping rpc-context-ref {
        description
           "A reference to RPC context.";
        leaf context-instance {
            type instance-identifier;
            description "Pointer to the context. ";
            mandatory true;
        }
    }

    extension "rpc-context-instance" {
        description
           "YANG language extension which defines enclosing (parent)
            schema node as referencable context for RPCs.

            The argument is identity which is used to identify RPC context
            type.";

        argument "context-type";
    }

    extension "context-reference" {
        argument "context-type";
    }

    extension "context-instance" {
        argument "context-type";
    }

    extension "instance-target" {
        argument "path";
    }
}
