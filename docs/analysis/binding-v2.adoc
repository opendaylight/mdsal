:bug: https://bugs.opendaylight.org/show_bug.cgi?id=
:toc:

= Binding Specification v2



== What is Java Binding Specification

* Binding specification defines mapping of YANG modeled data to
respective Java Objects, structures and DTOs
* has compile time and runtime aspects, compile time aspects are mostly
visible to users of MD-SAL
* Currently used specification is
https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping[Binding
Specification v1]

== Requirements

Interfaces & classes provided and generated by Binding Specification v2:

* SHOULD model YANG semantics correctly
* MUST NOT prevent support of YANG 1.1
* Provide / enforce maximal possible constrains during compile-time
** This prevents bugs at compile time, more allows for assumptions at
runtime and performance optimizations
* Code generation MUST BE isolated. Presence of additional model
should not change generation of original model.
* SHOULD allow for reusing instances of objects at various subtrees

== Known issues of Binding Specification 1

* <<correct-model-representation>>
* <<usability-issues>>
* <<missing-mappings>>

[[correct-model-representation]]
=== Issues preventing correct model generation

** <<namespace-collision>>
** <<spec-collision>>
** <<outer-inner-class-collision>>

[[namespace-collision]]
==== Grouping, data, typedef and identity namespaces collide

.Related bugs
** {bug}138[138: Grouping, data, typedef and identity namespaces collide]


This bugs shared common root in Binding Specification v1 and that was caused by
not accounting for identifier namespace differences between Java and YANG.

- Java has 1 namespace, where unique identifier is is *Package name with Class name*
- YANG has 6 separate namespaces and allows for same name to be used
in this separate namespaces.
Module and submodule namespace::
Each module and submodule name must be unique.
Extension namespace::
All extensions names defined in module and its submodules must be unique.
Typedef namespace::
All derived type names defined within a parent node or at the top
level of the module or its submodules must be unique.
Grouping namespace::
All grouping names defined within a parent node or at the top
level of the module or its submodules must be unique.
Data namespace::
All leafs, leaf-lists, lists, containers, choices, rpcs,
notifications, and anyxmls defined (directly or through a uses
statement) within a parent node or at the top level of the module
must be unique.
Identity namespace::
All identity names defined in a module and its submodules share
the same identity identifier namespace.

.Example valid model
[source, yang]
----
module example {
    namespace "urn:example";

    identity example {}
    typedef example {type string;}
    grouping example {}
    container example {
        container example {
          leaf example {type example;}
        }
    }
}
----

===== Proposed solution

* Use different packages names for identities, types, groupings and data tree
items.

.Example
* If module package name is `urn.example`
** `urn.example` - module specific items
** `urn.example.type` - interfaces / classes representing derived types
** `urn.example.grouping` - interfaces / classes representing grouping and their
children
** `urn.example.data` - interfaces / classes representing notifications, rpcs,
data tree

[[spec-collision]]
==== Methods introduced by Binding Specification conflicts with modeled items

.Related bugs
** {bug}157[157: Conflict appears when key of list is leaf with name `key`]


Binding Specification v1 uses getter pattern for representing nested children
derived from YANG model. Name of child is converted to valid JAVA name and
prepended with `is` or `get` prefix.

Unfortunately Java & Binding Specification v1 also uses `get` prefix for some
methods.


.Example conflicting model
[source, yang]
----
container example {

  list property {
    key "key";
    leaf key { // <1>
        type string;
    }
  }

  leaf implemented-interface { // <2>
    type string;
  }

  leaf class { // <3>
    type string;
  }

}
----
<1> Conflicts with `getKey` introduced by `Identifiable` which is used for lists
  with key
<2> Conflicts with `getImplementedInterface` defined in `DataContainer` which is
base interface of all generated lists, containers, cases, choices
<3> Conflicts with `getClass` defined in `Object` which is root of all Java classes

[[outer-inner-class-collision]]
==== Inner class with same name as outer class is not allowed

.Related bugs
* {bug}2360[2360: Inner class with same name as outer class is not allowed]

Inner classes are used for generation of anonymous `union`, `bit` and `enumeration` types
defined in model.

In Java inner class MUST NOT have same name as outer class, which causes compilation
error for following model:

[source, yang]
----
grouping flags {
  leaf flags {
    type bits {
      bit one;
      bit two;
    }
  }
}

grouping status {
  leaf status {
    type enumeration {
      enum open;
      enum closed;
    }
  }
}
----


==== Enumeration mapping is based on incorrect assumptions

.Related Bugs
* {bug}2332[2332:  Binding Java API Generator -> doesn't handle non-alphabetic signs in names of enum constants]

Enumeration mapping was based on notion / idea that names of possibles values
are `identifier` as defined in RFC6020, but actual name is string.

.RFC 6020: Section 9.6.4 The enum Statement
----
It takes as an argument a string which is the assigned name.  The
string MUST NOT be zero-length and MUST NOT have any leading or
trailing whitespace characters (any Unicode character with the
"White_Space" property).  The use of Unicode control codes SHOULD be
avoided.
----

This mapping makes impossible to represent following model:

[source, yang]
----
typedef math-operand {
  type enumeration {
    enum "+";
    enum "/";
    enum "*";
    enum "-";
  }
}
----

==== 4625: groupings should not share classes with their instantiations


=== Incompatibilities with allowed model upgrade paths

==== Multiple augmentations of same target should result in one interface

=== Mappings incompatible with YANG 1.1

==== Identity mapping does not allow for identities with multiple bases

YANG 1.1


.Example model
[source, yang]
----
module example-crypto-base {
  yang-version 1.1;
  namespace "urn:example:crypto-base";
  prefix "crypto";

  identity crypto-alg {
   description
     "Base identity from which all crypto algorithms
      are derived.";
  }

  identity symmetric-key {
   description
     "Base identity used to identify symmetric-key crypto
      algorithms.";
   }

  identity public-key {
   description
     "Base identity used to identify public-key crypto
      algorithms.";
   }
  }

  module example-des {
  yang-version 1.1;
  namespace "urn:example:des";
  prefix "des";

  import "example-crypto-base" {
   prefix "crypto";
  }

  identity des {
   base "crypto:crypto-alg";
   base "crypto:symmetric-key";
   description "DES crypto algorithm";
  }

  identity des3 {
   base "crypto:crypto-alg";
   base "crypto:symmetric-key";
   description "Triple DES crypto algorithm";
  }
}

----

==== Derived enumeration could limit valid values

==== Derived bits could limit valid values


[[missing-mappings]]
=== Missing Mappings of YANG concepts

* {bug}706[706]: Missing support for `anyxml` // Supplier<Source>

[[usability-issues]]
=== Usability issues

[[enumeration-naming]]
==== 2641: Enumeration value defined in yang model is translated without underscore


==== Generate Equivalency for comparison of items by `key` and `unique`

[[choice-case-childof]]
==== ChildOf<> does not properly work with Choice / Case

* {bug}1466[1466]: InstanceIdentifier is unable to represent Choice / Case, only children
* {bug}1644[1644]: InstanceIdentifier does not properly capture choice-case child relationship

[[list-mapping-semantics]]
==== Mapping of list and leaf-list does not properly captures modeled semantic

After analysis of specification, implementation of applications and
MD-SAL, we found out that `list` and `leaf-list` keyword actually has three different
behaviors based on combination of key and ordered-by statements.

In order to correctly expose this to Binding Applications,
representation in parent node should be extended to facilitate this
mapping should be changed.

.List mappings / behaviour
[cols=",,,",options="header",]
|===
|Key statement |Ordered-by |Behaviour |v2 Type
|key is defined |system (default) |Unordered map |Map
|key is defined |user |Ordered map |Map
|key is not defined |-- |Collection |List
|===

.Leaf list mapping / behaviour
[cols=",,",options="header",]
|===
|Ordered-by |Behaviour |v2 Type
|system (default) |Unordered Distinct |Set
|user |Ordered Distinct |Set
|===

[[empty-collections-instead-null]]
==== 1097:Return an empty list and never null from list-valued parameters

=== Other
* {bug}1478[1478]: Autoboxing support
* {bug}1095[1095]: Simplify InstanceIdentifer creation
* {bug}1117[1117]: Improve RPC API error handling
* {bug}1459[1459]: Reorganize yang-binding


[[leaf-leaf-list-instance-identifiers]]
==== Leaf, leaf-list Instance Identifiers

Instance Identifier currently are constructed using classes as path
arguments

* is fine and allows for Instance Identifier to capture target type, but
works only for *container* and *list*

Instance Identifier needs to be extended to allow targeting:

* leaves
* choice and case statements

[[proposed-solution-1]]
Proposed solution

Introduce *LeafPathArgument*. LeafPathArguments for leafes will be
stored in interface describing parent container as constants.
This will allow for use such as:

[source, java]
----
InstanceIdentifier<Boolean> activePath = InstanceIdentifier.create(Foo.class).leaf(Foo.ACTIVE);
ListenableFuture<Optional<Boolean>> active = tx.read(CONFIGURATION,activePath);
----

This will require changing signature of MD-SAL to allow Object in its
interfaces if we want to read boolean directly.
Other approach is to have special DTO which implements DataObject and
encapsulates LeafValue, this will allow MD-SAL to still limit input
to DataObject.


[source, java]
----
InstanceIdentifier<LeafValue<Boolean>> activePath = InstanceIdentifier.create(Foo.class).leaf(Foo.ACTIVE);
ListenableFuture<Optional<LeafValue<Boolean>>> active = tx.read(CONFIGURATION,activePath);
----

Note: Use of Optional is property of MD-SAL and not of Binding
Specification


==== Collections should be really immutable in immutable transfer objects
